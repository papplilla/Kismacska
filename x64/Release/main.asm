; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_09HDLCNAPM@input?4jpg?$AA@		; `string'
PUBLIC	??_C@_0BL@EIJCCJGD@Input?5resolution?3?5?$CF4dx?$CF4d?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@ICFMFDGO@Start?5convolution?6?$AA@	; `string'
PUBLIC	??_C@_0BD@NGKMKCMP@C?5CPU?5TIME?3?5?$CF4?44f?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@CKJPLJHO@C?5Mpixel?1s?3?5?$CF4?44f?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@GOPADODP@SSE?5CPU?5TIME?3?5?$CF4?44f?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@JCMDCFIO@SSE?5Mpixel?1s?3?5?$CF4?44f?6?$AA@ ; `string'
PUBLIC	??_C@_0L@DMOPMCBB@output?4jpg?$AA@		; `string'
EXTRN	__imp_ilGenImages:PROC
EXTRN	__imp_ilGetInteger:PROC
EXTRN	__imp_ilGetData:PROC
EXTRN	__imp_ilBindImage:PROC
EXTRN	__imp_ilInit:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	__imp_iluInit:PROC
EXTRN	_aligned_malloc:PROC
EXTRN	__imp_ilDeleteImages:PROC
EXTRN	__imp_ilLoadImage:PROC
EXTRN	__acrt_iob_func:PROC
EXTRN	__imp_ilSetData:PROC
EXTRN	__imp_ilEnable:PROC
EXTRN	__imp_ilSaveImage:PROC
EXTRN	clock:PROC
EXTRN	_aligned_free:PROC
;	COMDAT ??_C@_0L@DMOPMCBB@output?4jpg?$AA@
CONST	SEGMENT
??_C@_0L@DMOPMCBB@output?4jpg?$AA@ DB 'output.jpg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JCMDCFIO@SSE?5Mpixel?1s?3?5?$CF4?44f?6?$AA@
CONST	SEGMENT
??_C@_0BF@JCMDCFIO@SSE?5Mpixel?1s?3?5?$CF4?44f?6?$AA@ DB 'SSE Mpixel/s: %'
	DB	'4.4f', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GOPADODP@SSE?5CPU?5TIME?3?5?$CF4?44f?6?$AA@
CONST	SEGMENT
??_C@_0BF@GOPADODP@SSE?5CPU?5TIME?3?5?$CF4?44f?6?$AA@ DB 'SSE CPU TIME: %'
	DB	'4.4f', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CKJPLJHO@C?5Mpixel?1s?3?5?$CF4?44f?6?$AA@
CONST	SEGMENT
??_C@_0BD@CKJPLJHO@C?5Mpixel?1s?3?5?$CF4?44f?6?$AA@ DB 'C Mpixel/s: %4.4f'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NGKMKCMP@C?5CPU?5TIME?3?5?$CF4?44f?6?$AA@
CONST	SEGMENT
??_C@_0BD@NGKMKCMP@C?5CPU?5TIME?3?5?$CF4?44f?6?$AA@ DB 'C CPU TIME: %4.4f'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ICFMFDGO@Start?5convolution?6?$AA@
CONST	SEGMENT
??_C@_0BD@ICFMFDGO@Start?5convolution?6?$AA@ DB 'Start convolution', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EIJCCJGD@Input?5resolution?3?5?$CF4dx?$CF4d?6?$AA@
CONST	SEGMENT
??_C@_0BL@EIJCCJGD@Input?5resolution?3?5?$CF4dx?$CF4d?6?$AA@ DB 'Input re'
	DB	'solution: %4dx%4d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HDLCNAPM@input?4jpg?$AA@
CONST	SEGMENT
??_C@_09HDLCNAPM@input?4jpg?$AA@ DB 'input.jpg', 00H	; `string'
CONST	ENDS
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	main
PUBLIC	printf
PUBLIC	_vfprintf_l
PUBLIC	__local_stdio_printf_options
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN76
	DD	imagerel $LN76+1075
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN8
	DD	imagerel $LN8+83
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 041b01H
	DD	07017521bH
	DD	030156016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	0154519H
	DD	0a9833H
	DD	0b882eH
	DD	0c7829H
	DD	0d6824H
	DD	024641fH
	DD	023541fH
	DD	022341fH
	DD	01c011fH
	DD	0e016f018H
	DD	0c012d014H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	090H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$dead$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, rdx
	mov	rsi, rcx

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rbx
	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 640  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Format$ = 80
printf	PROC						; COMDAT

; 950  : {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	__acrt_iob_func
	mov	rbx, rax

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 955  :     __crt_va_end(_ArgList);
; 956  :     return _Result;
; 957  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\bme\education\ujrakonfig_2018\gyak\gyak1_mo\_src\main.cpp
;	COMDAT main
_TEXT	SEGMENT
ilImg$ = 48
imgSrcExt$1$ = 56
s0$2$ = 56
tv2134 = 64
imgDstConv$1$ = 64
imgData$1$ = 72
tv2125 = 80
filter_laplace$ = 88
__$ArrayPad$ = 144
main	PROC						; COMDAT

; 21   : {

$LN76:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 224				; 000000e0H
	vmovaps	XMMWORD PTR [rax-56], xmm6
	vmovaps	XMMWORD PTR [rax-72], xmm7
	vmovaps	XMMWORD PTR [rax-88], xmm8
	vmovaps	XMMWORD PTR [rax-104], xmm9
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 22   : 	ilInit(); iluInit();

	call	QWORD PTR __imp_ilInit
	call	QWORD PTR __imp_iluInit

; 23   : 	ILboolean ret;
; 24   : 	ILuint ilImg=0;

	xor	esi, esi

; 25   : 	ilGenImages(1, &ilImg);

	lea	rdx, QWORD PTR ilImg$[rsp]
	mov	DWORD PTR ilImg$[rsp], esi
	lea	ecx, QWORD PTR [rsi+1]
	call	QWORD PTR __imp_ilGenImages

; 26   : 	ilBindImage(ilImg);

	mov	ecx, DWORD PTR ilImg$[rsp]
	call	QWORD PTR __imp_ilBindImage

; 27   :     ret = ilLoadImage((const char*)("input.jpg"));

	lea	rcx, OFFSET FLAT:??_C@_09HDLCNAPM@input?4jpg?$AA@
	call	QWORD PTR __imp_ilLoadImage

; 28   : 	ILubyte* imgData = ilGetData(); 

	call	QWORD PTR __imp_ilGetData

; 29   : 
; 30   : 	int imgWidth = ilGetInteger(IL_IMAGE_WIDTH);

	mov	ecx, 3556				; 00000de4H
	mov	QWORD PTR imgData$1$[rsp], rax
	mov	r14, rax
	call	QWORD PTR __imp_ilGetInteger

; 31   : 	int imgHeight = ilGetInteger(IL_IMAGE_HEIGHT);

	mov	ecx, 3557				; 00000de5H
	mov	edi, eax
	call	QWORD PTR __imp_ilGetInteger

; 32   : 	ILint imgOrigin = ilGetInteger(IL_ORIGIN_MODE);

	mov	ecx, 1539				; 00000603H
	mov	r13d, eax
	call	QWORD PTR __imp_ilGetInteger

; 33   : 
; 34   : 	printf("Input resolution: %4dx%4d\n", imgWidth, imgHeight);

	mov	r8d, r13d
	lea	rcx, OFFSET FLAT:??_C@_0BL@EIJCCJGD@Input?5resolution?3?5?$CF4dx?$CF4d?6?$AA@
	mov	edx, edi
	call	printf

; 35   : 
; 36   : 	unsigned char *imgSrcExt;
; 37   : 	int imgWidthF = imgWidth+FILTER_W-1;
; 38   : 	int imgHeightF = imgHeight+FILTER_H-1;

	lea	r15d, DWORD PTR [r13+4]

; 39   : 	int imgFOfssetW = (FILTER_W-1)/2;
; 40   : 	int imgFOfssetH = (FILTER_H-1)/2;
; 41   : 	imgSrcExt = (unsigned char *)(_aligned_malloc(3*imgWidthF*imgHeightF*sizeof(unsigned char), 32));

	mov	ecx, r15d
	lea	ebx, DWORD PTR [rdi+4]
	imul	ecx, ebx
	lea	edx, QWORD PTR [rsi+32]
	lea	eax, DWORD PTR [rcx+rcx*2]
	cdqe
	mov	rcx, rax
	mov	QWORD PTR tv2134[rsp], rax
	call	_aligned_malloc
	mov	QWORD PTR imgSrcExt$1$[rsp], rax
	mov	rbp, rax

; 42   :     int row, col;
; 43   : 
; 44   : 	for (row=0; row<imgHeightF; row++)

	test	r15d, r15d
	jle	SHORT $LN3@main

; 22   : 	ilInit(); iluInit();

	lea	ecx, DWORD PTR [rbx+rbx*2]
	mov	r10d, r15d
	movsxd	r11, ecx
	mov	r9d, esi
	npad	4
$LL4@main:

; 45   : 	{
; 46   : 		for (col=0; col<imgWidthF;col++)

	test	ebx, ebx
	jle	SHORT $LN2@main

; 47   : 		{
; 48   : 			int pixel = (row*imgWidthF + col)*3;
; 49   : 			*(imgSrcExt + pixel + 0) = 0;

	lea	rax, QWORD PTR [rbp+1]
	mov	rdx, rbp
	sub	rdx, rax
	lea	rcx, QWORD PTR [r9+rax]
	mov	r8, rbp
	sub	r8, rax
	mov	eax, ebx
	npad	6
$LL7@main:
	mov	BYTE PTR [rdx+rcx], sil

; 50   : 			*(imgSrcExt + pixel + 1) = 0;

	mov	BYTE PTR [rcx], sil

; 51   : 			*(imgSrcExt + pixel + 2) = 0;

	mov	BYTE PTR [r8+rcx+2], sil
	lea	rcx, QWORD PTR [rcx+3]
	sub	rax, 1
	jne	SHORT $LL7@main
$LN2@main:

; 42   :     int row, col;
; 43   : 
; 44   : 	for (row=0; row<imgHeightF; row++)

	add	r9, r11
	sub	r10, 1
	jne	SHORT $LL4@main
$LN3@main:

; 52   : 		}
; 53   : 	}
; 54   : 
; 55   : 	for (row=0; row<imgHeight; row++)

	test	r13d, r13d
	jle	$LN9@main
	lea	eax, DWORD PTR [rdi+rdi*2]
	mov	r15, r13
	movsxd	r12, eax
	lea	eax, DWORD PTR [rbx+1]
	lea	ecx, DWORD PTR [rax+rax*2]
	lea	eax, DWORD PTR [rbx+rbx*2]
	add	ecx, ecx
	cdqe
	mov	ebx, 2
	mov	QWORD PTR tv2125[rsp], rax
	movsxd	r11, ecx
	npad	5
$LL10@main:

; 56   : 	{
; 57   : 		for (col=0; col<imgWidth;col++)

	test	edi, edi
	jle	SHORT $LN8@main
	mov	rax, rsi
	lea	rcx, QWORD PTR [r11+rbp]
	sub	rax, r11
	mov	rdx, rdi
	sub	rax, rbp
	mov	ebp, 1
	lea	r8, QWORD PTR [rax+r14]
	lea	r9, QWORD PTR [rax+r14]
	lea	r10, QWORD PTR [rax+r14]
	npad	11
$LL13@main:

; 58   : 		{
; 59   : 			int pixel_dst = ((row+imgFOfssetH)*imgWidthF + (col+imgFOfssetW))*3;
; 60   : 			int pixel_src = (row*imgWidth + col)*3;
; 61   : 			*(imgSrcExt + pixel_dst + 0) = (unsigned char)(*(imgData + pixel_src + 0));

	movzx	eax, BYTE PTR [r8+rcx]
	mov	BYTE PTR [rcx], al

; 62   : 			*(imgSrcExt + pixel_dst + 1) = (unsigned char)(*(imgData + pixel_src + 1));

	movzx	eax, BYTE PTR [r9+rcx+1]
	mov	BYTE PTR [rcx+rbp], al

; 63   : 			*(imgSrcExt + pixel_dst + 2) = (unsigned char)(*(imgData + pixel_src + 2));

	movzx	eax, BYTE PTR [r10+rcx+2]
	mov	BYTE PTR [rbx+rcx], al
	lea	rcx, QWORD PTR [rcx+3]
	sub	rdx, rbp
	jne	SHORT $LL13@main
	mov	rbp, QWORD PTR imgSrcExt$1$[rsp]
	mov	r14, QWORD PTR imgData$1$[rsp]
	mov	rax, QWORD PTR tv2125[rsp]
$LN8@main:

; 52   : 		}
; 53   : 	}
; 54   : 
; 55   : 	for (row=0; row<imgHeight; row++)

	add	r11, rax
	add	rsi, r12
	sub	r15, 1
	jne	SHORT $LL10@main
	lea	ebx, DWORD PTR [rdi+4]
$LN9@main:

; 64   : 		}
; 65   : 	}
; 66   : 
; 67   : 	unsigned char *imgRes;
; 68   : 	imgRes = (unsigned char *)(_aligned_malloc(3 * imgWidth*imgHeight * sizeof(unsigned char), 32));

	mov	r12d, r13d
	mov	edx, 32					; 00000020H
	imul	r12d, edi
	lea	eax, DWORD PTR [r12+r12*2]
	movsxd	rcx, eax
	call	_aligned_malloc
	vmovdqu	ymm0, YMMWORD PTR __ymm@ffffffffffff0018ffffffffffffffffffffffffffffffffffffffffffffffff
	vmovdqu	xmm1, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff

; 69   : 
; 70   : // IMAGE PROCESSING
; 71   : //---------------------------------------------------------------------------------------
; 72   : 	clock_t s0, e0;
; 73   :     double d0;
; 74   : 
; 75   : 	short filter_laplace[] = {-1, -1, -1, -1, -1,
; 76   : 	                          -1, -1, -1, -1, -1,
; 77   : 	                          -1, -1, 24, -1, -1,
; 78   : 		                      -1, -1, -1, -1, -1,
; 79   : 		                      -1, -1, -1, -1, -1};
; 80   : 	double mpixel;
; 81   : 
; 82   : 	short *imgDstConv;
; 83   : 	imgDstConv = (short*)(_aligned_malloc(3 * imgWidthF*imgHeightF * sizeof(short), 32));

	mov	rcx, QWORD PTR tv2134[rsp]
	mov	rsi, rax
	or	eax, -1
	add	rcx, rcx
	vmovdqu	YMMWORD PTR filter_laplace$[rsp], ymm0
	vmovdqu	XMMWORD PTR filter_laplace$[rsp+32], xmm1
	mov	WORD PTR filter_laplace$[rsp+48], ax
	lea	edx, QWORD PTR [rax+33]
	vzeroupper
	call	_aligned_malloc

; 84   : 
; 85   : 	printf("Start convolution\n");

	lea	rcx, OFFSET FLAT:??_C@_0BD@ICFMFDGO@Start?5convolution?6?$AA@
	mov	QWORD PTR imgDstConv$1$[rsp], rax
	call	printf

; 86   : 	s0 = clock();

	call	clock
	mov	DWORD PTR s0$2$[rsp], eax
	mov	r15d, 100				; 00000064H
	npad	11
$LL16@main:

; 87   : for (int r=0; r<RUNS; r++)
; 88   : {
; 89   : #if 0
; 90   : 	conv_filter(imgHeight, imgWidth, imgWidthF,
; 91   : 		filter_laplace, imgSrcExt, imgRes);
; 92   : #endif
; 93   : 
; 94   : #if 1
; 95   :     conv_filter_avx(imgHeight, imgWidth, imgWidthF,

	mov	QWORD PTR [rsp+40], rsi
	lea	r9, QWORD PTR filter_laplace$[rsp]
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], rbp
	mov	edx, edi
	mov	ecx, r13d
	call	?conv_filter_avx@@YAXHHHPEAFPEAE1@Z	; conv_filter_avx
	sub	r15, 1
	jne	SHORT $LL16@main

; 96   : 				filter_laplace, imgSrcExt, imgRes);
; 97   : #endif
; 98   : }
; 99   : 
; 100  :     e0 = clock();

	call	clock

; 101  :     d0 = (double)(e0-s0)/(RUNS*CLOCKS_PER_SEC);

	sub	eax, DWORD PTR s0$2$[rsp]

; 102  : 	mpixel = (imgWidth*imgHeight/d0)/1000000;
; 103  :     printf("C CPU TIME: %4.4f\n", d0);

	lea	rcx, OFFSET FLAT:??_C@_0BD@NGKMKCMP@C?5CPU?5TIME?3?5?$CF4?44f?6?$AA@
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2sd xmm0, xmm0, eax
	vdivsd	xmm6, xmm0, QWORD PTR __real@40f86a0000000000
	vmovaps	xmm1, xmm6
	vmovq	rdx, xmm1
	call	printf
	vxorps	xmm8, xmm8, xmm8
	vcvtsi2sd xmm8, xmm8, r12d
	vdivsd	xmm0, xmm8, xmm6
	vdivsd	xmm1, xmm0, QWORD PTR __real@412e848000000000

; 104  : 	printf("C Mpixel/s: %4.4f\n", mpixel);

	vmovq	rdx, xmm1
	lea	rcx, OFFSET FLAT:??_C@_0BD@CKJPLJHO@C?5Mpixel?1s?3?5?$CF4?44f?6?$AA@
	call	printf

; 105  : 
; 106  : 
; 107  : 
; 108  : 	    s0 = clock();

	call	clock
	mov	ebx, eax

; 109  : for (int r=0; r<RUNS; r++)
; 110  : {
; 111  : /*
; 112  : 	conv_filter_sse(imgHeight, imgWidth, imgHeightF, imgWidthF,
; 113  : 				imgFOfssetH, imgFOfssetW,
; 114  : 				filter_laplace, imgFloat, imgFloatRes);
; 115  : 	
; 116  : 	conv_filter(imgHeight, imgWidth, imgHeightF, imgWidthF,
; 117  : 		imgFOfssetH, imgFOfssetW,
; 118  : 		filter_laplace, imgFloat, imgFloatRes);
; 119  : 
; 120  : 	conv_filter_block_sse(imgHeight, imgWidth, imgHeightF, imgWidthF,
; 121  : 		imgFOfssetH, imgFOfssetW,
; 122  : 		filter_laplace, imgFloat, imgFloatRes);
; 123  : */
; 124  : }
; 125  :     e0 = clock();

	call	clock

; 126  :     d0 = (double)(e0-s0)/(RUNS*CLOCKS_PER_SEC);

	sub	eax, ebx

; 127  : 	mpixel = (imgWidth*imgHeight/d0)/1000000;
; 128  :     printf("SSE CPU TIME: %4.4f\n", d0*1000);

	lea	rcx, OFFSET FLAT:??_C@_0BF@GOPADODP@SSE?5CPU?5TIME?3?5?$CF4?44f?6?$AA@
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2sd xmm0, xmm0, eax
	vdivsd	xmm6, xmm0, QWORD PTR __real@40f86a0000000000
	vmulsd	xmm1, xmm6, QWORD PTR __real@408f400000000000
	vmovq	rdx, xmm1
	call	printf
	vdivsd	xmm0, xmm8, xmm6
	vdivsd	xmm1, xmm0, QWORD PTR __real@412e848000000000

; 129  : 	printf("SSE Mpixel/s: %4.4f\n", mpixel);

	vmovq	rdx, xmm1
	lea	rcx, OFFSET FLAT:??_C@_0BF@JCMDCFIO@SSE?5Mpixel?1s?3?5?$CF4?44f?6?$AA@
	call	printf

; 130  : 
; 131  : /*
; 132  :     s0 = clock();
; 133  : for (int r=0; r<RUNS; r++)
; 134  : {
; 135  :     conv_filter_asm(imgHeight, imgWidth, imgHeightF, imgWidthF,
; 136  : 				imgFOfssetH, imgFOfssetW,
; 137  : 				filter_laplace, imgFloat, imgFloatRes);
; 138  : }
; 139  :     e0 = clock();
; 140  :     d0 = (double)(e0-s0)/(RUNS*CLOCKS_PER_SEC);
; 141  : 	mpixel = (imgWidth*imgHeight/d0)/1000000;
; 142  : 	printf("ASM CPU TIME: %4.4f\n", d0);
; 143  : 	printf("ASM Mpixel/s: %4.4f\n", mpixel);
; 144  : */
; 145  : 
; 146  : //---------------------------------------------------------------------------------------
; 147  : // IMAGE PROCESSING END
; 148  : 
; 149  : 	for (row=0; row<imgHeight; row++)

	test	r13d, r13d
	jle	SHORT $LN21@main

; 109  : for (int r=0; r<RUNS; r++)
; 110  : {
; 111  : /*
; 112  : 	conv_filter_sse(imgHeight, imgWidth, imgHeightF, imgWidthF,
; 113  : 				imgFOfssetH, imgFOfssetW,
; 114  : 				filter_laplace, imgFloat, imgFloatRes);
; 115  : 	
; 116  : 	conv_filter(imgHeight, imgWidth, imgHeightF, imgWidthF,
; 117  : 		imgFOfssetH, imgFOfssetW,
; 118  : 		filter_laplace, imgFloat, imgFloatRes);
; 119  : 
; 120  : 	conv_filter_block_sse(imgHeight, imgWidth, imgHeightF, imgWidthF,
; 121  : 		imgFOfssetH, imgFOfssetW,
; 122  : 		filter_laplace, imgFloat, imgFloatRes);
; 123  : */
; 124  : }
; 125  :     e0 = clock();

	lea	eax, DWORD PTR [rdi+rdi*2]
	mov	r11, r14
	movsxd	r15, eax
	mov	rbx, r13
	npad	4
$LL22@main:

; 150  : 	{
; 151  : 		for (col=0; col<imgWidth;col++)

	test	edi, edi
	jle	SHORT $LN20@main
	mov	r8, rsi
	mov	r9, rsi
	sub	r8, r14
	sub	r9, r14
	mov	r10, rsi
	mov	rcx, r11
	sub	r10, r14
	mov	rdx, rdi
	mov	r12d, 2
	mov	r13d, 1
	npad	8
$LL25@main:

; 152  : 		{
; 153  : 			int pixel_src = (row*imgWidth + col)*3;
; 154  : 			int pixel_dst = (row*imgWidth + col)*3;
; 155  : 			*(imgData + pixel_dst + 0) = (ILubyte)(*(imgRes + pixel_src + 0));

	movzx	eax, BYTE PTR [r8+rcx]
	mov	BYTE PTR [rcx], al

; 156  : 			*(imgData + pixel_dst + 1) = (ILubyte)(*(imgRes + pixel_src + 1));

	movzx	eax, BYTE PTR [rcx+r9+1]
	mov	BYTE PTR [rcx+r13], al

; 157  : 			*(imgData + pixel_dst + 2) = (ILubyte)(*(imgRes + pixel_src + 2));

	movzx	eax, BYTE PTR [rcx+r10+2]
	mov	BYTE PTR [rcx+r12], al
	lea	rcx, QWORD PTR [rcx+3]
	sub	rdx, r13
	jne	SHORT $LL25@main
$LN20@main:

; 130  : 
; 131  : /*
; 132  :     s0 = clock();
; 133  : for (int r=0; r<RUNS; r++)
; 134  : {
; 135  :     conv_filter_asm(imgHeight, imgWidth, imgHeightF, imgWidthF,
; 136  : 				imgFOfssetH, imgFOfssetW,
; 137  : 				filter_laplace, imgFloat, imgFloatRes);
; 138  : }
; 139  :     e0 = clock();
; 140  :     d0 = (double)(e0-s0)/(RUNS*CLOCKS_PER_SEC);
; 141  : 	mpixel = (imgWidth*imgHeight/d0)/1000000;
; 142  : 	printf("ASM CPU TIME: %4.4f\n", d0);
; 143  : 	printf("ASM Mpixel/s: %4.4f\n", mpixel);
; 144  : */
; 145  : 
; 146  : //---------------------------------------------------------------------------------------
; 147  : // IMAGE PROCESSING END
; 148  : 
; 149  : 	for (row=0; row<imgHeight; row++)

	add	r11, r15
	sub	rbx, 1
	jne	SHORT $LL22@main
$LN21@main:

; 158  : 		}
; 159  : 	}
; 160  : 
; 161  : 	_aligned_free(imgDstConv);

	mov	rcx, QWORD PTR imgDstConv$1$[rsp]
	call	_aligned_free

; 162  : 	_aligned_free(imgSrcExt);

	mov	rcx, rbp
	call	_aligned_free

; 163  :     _aligned_free(imgRes);

	mov	rcx, rsi
	call	_aligned_free

; 164  : 
; 165  : 	ret = ilSetData(imgData);

	mov	rcx, r14
	call	QWORD PTR __imp_ilSetData

; 166  : 	ilEnable(IL_FILE_OVERWRITE);

	mov	ecx, 1568				; 00000620H
	call	QWORD PTR __imp_ilEnable

; 167  :     ilSaveImage((const char*)("output.jpg"));

	lea	rcx, OFFSET FLAT:??_C@_0L@DMOPMCBB@output?4jpg?$AA@
	call	QWORD PTR __imp_ilSaveImage

; 168  : 	ilDeleteImages(1, &ilImg);

	lea	rdx, QWORD PTR ilImg$[rsp]
	mov	ecx, 1
	call	QWORD PTR __imp_ilDeleteImages

; 169  : }

	xor	eax, eax
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	vmovaps	xmm6, XMMWORD PTR [r11-16]
	vmovaps	xmm7, XMMWORD PTR [r11-32]
	vmovaps	xmm8, XMMWORD PTR [r11-48]
	vmovaps	xmm9, XMMWORD PTR [r11-64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

	ret	0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
END
