; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	D:\VS_Projects\Hetero_HW_1\_src\conv_filter.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?conv_filter@@YAXHHHPAFPAE1@Z			; conv_filter
EXTRN	___report_rangecheckfailure:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__vcomp_for_static_end:PROC
EXTRN	__vcomp_for_static_simple_init:PROC
EXTRN	__vcomp_fork:PROC
EXTRN	__You_must_link_with_Microsoft_OpenMP_library:DWORD
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\vs_projects\hetero_hw_1\_src\conv_filter.cpp
;	COMDAT ?conv_filter$omp$1@@YAXHHHPAFPAE1@Z
_TEXT	SEGMENT
$T1 = -412						; size = 4
$T2 = -400						; size = 4
$T3 = -388						; size = 4
_$S3$4 = -184						; size = 4
_$S2$5 = -172						; size = 4
_$S1$6 = -160						; size = 4
_rgba$7 = -148						; size = 4
_rgba$8 = -136						; size = 4
_pixel_src$9 = -124					; size = 4
_rgba$10 = -112						; size = 4
_fx$11 = -100						; size = 4
_fy$12 = -88						; size = 4
_rd_offset$13 = -76					; size = 4
_fval$14 = -64						; size = 6
_col$15 = -48						; size = 4
_rd_base$16 = -36					; size = 4
_wr_base$17 = -24					; size = 4
_row$18 = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_imgHeight$ = 8						; size = 4
_imgWidth$ = 12						; size = 4
_imgWidthF$ = 16					; size = 4
_filter$ = 20						; size = 4
_imgSrcExt$ = 24					; size = 4
_imgDst$ = 28						; size = 4
?conv_filter$omp$1@@YAXHHHPAFPAE1@Z PROC		; conv_filter$omp$1, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-416]
	mov	ecx, 104				; 00000068H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 18   : 	for (int row=0; row<imgHeight; row++)

	mov	DWORD PTR _$S1$6[ebp], 0
	mov	DWORD PTR _$S3$4[ebp], 1
	mov	eax, DWORD PTR _imgHeight$[ebp]
	mov	DWORD PTR _$S2$5[ebp], eax
	mov	eax, DWORD PTR _$S1$6[ebp]
	cmp	eax, DWORD PTR _$S2$5[ebp]
	jge	$LN27@conv_filte
	mov	ecx, DWORD PTR _$S2$5[ebp]
	sub	ecx, 1
	mov	DWORD PTR _$S2$5[ebp], ecx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _$S3$4[ebp]
	push	edx
	mov	eax, DWORD PTR _$S2$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _$S1$6[ebp]
	push	ecx
	call	__vcomp_for_static_simple_init
	add	esp, 24					; 00000018H
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _row$18[ebp], eax
	jmp	SHORT $LN2@conv_filte
$LN2@conv_filte:
	mov	ecx, DWORD PTR _row$18[ebp]
	add	ecx, DWORD PTR _$S3$4[ebp]
	mov	DWORD PTR _row$18[ebp], ecx
$LN2@conv_filte:
	mov	edx, DWORD PTR _row$18[ebp]
	cmp	edx, DWORD PTR $T1[ebp]
	jg	$LN3@conv_filte

; 19   : 	{
; 20   : 		int wr_base = row*imgWidth*3;

	mov	eax, DWORD PTR _row$18[ebp]
	imul	eax, DWORD PTR _imgWidth$[ebp]
	imul	ecx, eax, 3
	mov	DWORD PTR _wr_base$17[ebp], ecx

; 21   : 		int rd_base = row*imgWidthF*3;

	mov	eax, DWORD PTR _row$18[ebp]
	imul	eax, DWORD PTR _imgWidthF$[ebp]
	imul	ecx, eax, 3
	mov	DWORD PTR _rd_base$16[ebp], ecx

; 22   : 		for (int col=0; col<imgWidth; col++)

	mov	DWORD PTR _col$15[ebp], 0
	jmp	SHORT $LN6@conv_filte
$LN4@conv_filte:
	mov	eax, DWORD PTR _col$15[ebp]
	add	eax, 1
	mov	DWORD PTR _col$15[ebp], eax
$LN6@conv_filte:
	mov	eax, DWORD PTR _col$15[ebp]
	cmp	eax, DWORD PTR _imgWidth$[ebp]
	jge	$LN5@conv_filte

; 23   : 		{
; 24   : 			short fval[3] = {0,0,0};

	xor	eax, eax
	mov	WORD PTR _fval$14[ebp], ax
	xor	eax, eax
	mov	WORD PTR _fval$14[ebp+2], ax
	xor	eax, eax
	mov	WORD PTR _fval$14[ebp+4], ax

; 25   : 			int rd_offset = 0;

	mov	DWORD PTR _rd_offset$13[ebp], 0

; 26   : 			for (int fy=0; fy<FILTER_H; fy++)

	mov	DWORD PTR _fy$12[ebp], 0
	jmp	SHORT $LN9@conv_filte
$LN7@conv_filte:
	mov	eax, DWORD PTR _fy$12[ebp]
	add	eax, 1
	mov	DWORD PTR _fy$12[ebp], eax
$LN9@conv_filte:
	cmp	DWORD PTR _fy$12[ebp], 5
	jge	$LN8@conv_filte

; 27   : 			{
; 28   : 				for (int fx=0; fx<FILTER_W; fx++)

	mov	DWORD PTR _fx$11[ebp], 0
	jmp	SHORT $LN12@conv_filte
$LN10@conv_filte:
	mov	eax, DWORD PTR _fx$11[ebp]
	add	eax, 1
	mov	DWORD PTR _fx$11[ebp], eax
$LN12@conv_filte:
	cmp	DWORD PTR _fx$11[ebp], 5
	jge	SHORT $LN11@conv_filte

; 29   : 				{
; 30   : 					for (int rgba=0; rgba<3; rgba++)

	mov	DWORD PTR _rgba$10[ebp], 0
	jmp	SHORT $LN15@conv_filte
$LN13@conv_filte:
	mov	eax, DWORD PTR _rgba$10[ebp]
	add	eax, 1
	mov	DWORD PTR _rgba$10[ebp], eax
$LN15@conv_filte:
	cmp	DWORD PTR _rgba$10[ebp], 3
	jge	SHORT $LN14@conv_filte

; 31   : 					{
; 32   : 						int pixel_src = rd_base + rd_offset;

	mov	eax, DWORD PTR _rd_base$16[ebp]
	add	eax, DWORD PTR _rd_offset$13[ebp]
	mov	DWORD PTR _pixel_src$9[ebp], eax

; 33   : 						fval[rgba] = fval[rgba] + *(filter+fy*FILTER_W+fx) * (short)(*(imgSrcExt + pixel_src + rgba));

	mov	eax, DWORD PTR _rgba$10[ebp]
	movsx	ecx, WORD PTR _fval$14[ebp+eax*2]
	imul	edx, DWORD PTR _fy$12[ebp], 5
	mov	eax, DWORD PTR _filter$[ebp]
	lea	edx, DWORD PTR [eax+edx*2]
	mov	eax, DWORD PTR _fx$11[ebp]
	movsx	edx, WORD PTR [edx+eax*2]
	mov	eax, DWORD PTR _imgSrcExt$[ebp]
	add	eax, DWORD PTR _pixel_src$9[ebp]
	mov	esi, DWORD PTR _rgba$10[ebp]
	movzx	eax, BYTE PTR [eax+esi]
	imul	edx, eax
	add	ecx, edx
	mov	edx, DWORD PTR _rgba$10[ebp]
	mov	WORD PTR _fval$14[ebp+edx*2], cx

; 34   : 					}

	jmp	SHORT $LN13@conv_filte
$LN14@conv_filte:

; 35   : 					rd_offset = rd_offset + 3;

	mov	eax, DWORD PTR _rd_offset$13[ebp]
	add	eax, 3
	mov	DWORD PTR _rd_offset$13[ebp], eax

; 36   : 				}

	jmp	SHORT $LN10@conv_filte
$LN11@conv_filte:

; 37   : 				rd_offset = rd_offset - 5*3 + imgWidthF*3;

	imul	eax, DWORD PTR _imgWidthF$[ebp], 3
	mov	ecx, DWORD PTR _rd_offset$13[ebp]
	lea	edx, DWORD PTR [ecx+eax-15]
	mov	DWORD PTR _rd_offset$13[ebp], edx

; 38   : 				
; 39   : 			}

	jmp	$LN7@conv_filte
$LN8@conv_filte:

; 40   : 
; 41   : 			for (int rgba=0; rgba<3; rgba++)

	mov	DWORD PTR _rgba$8[ebp], 0
	jmp	SHORT $LN18@conv_filte
$LN16@conv_filte:
	mov	eax, DWORD PTR _rgba$8[ebp]
	add	eax, 1
	mov	DWORD PTR _rgba$8[ebp], eax
$LN18@conv_filte:
	cmp	DWORD PTR _rgba$8[ebp], 3
	jge	SHORT $LN17@conv_filte

; 42   : 			{
; 43   : 				if (fval[rgba]>255) fval[rgba]=255;

	mov	eax, DWORD PTR _rgba$8[ebp]
	movsx	ecx, WORD PTR _fval$14[ebp+eax*2]
	cmp	ecx, 255				; 000000ffH
	jle	SHORT $LN22@conv_filte
	mov	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _rgba$8[ebp]
	mov	WORD PTR _fval$14[ebp+ecx*2], ax
$LN22@conv_filte:

; 44   : 				if (fval[rgba]<0)   fval[rgba]=0;

	mov	eax, DWORD PTR _rgba$8[ebp]
	movsx	ecx, WORD PTR _fval$14[ebp+eax*2]
	test	ecx, ecx
	jge	SHORT $LN23@conv_filte
	mov	eax, DWORD PTR _rgba$8[ebp]
	shl	eax, 1
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 6
	jae	SHORT $LN25@conv_filte
	jmp	SHORT $LN26@conv_filte
$LN25@conv_filte:
	call	___report_rangecheckfailure
$LN26@conv_filte:
	xor	ecx, ecx
	mov	edx, DWORD PTR $T3[ebp]
	mov	WORD PTR _fval$14[ebp+edx], cx
$LN23@conv_filte:

; 45   : 			}

	jmp	SHORT $LN16@conv_filte
$LN17@conv_filte:

; 46   : 
; 47   : 			for (int rgba=0; rgba<3; rgba++)

	mov	DWORD PTR _rgba$7[ebp], 0
	jmp	SHORT $LN21@conv_filte
$LN19@conv_filte:
	mov	eax, DWORD PTR _rgba$7[ebp]
	add	eax, 1
	mov	DWORD PTR _rgba$7[ebp], eax
$LN21@conv_filte:
	cmp	DWORD PTR _rgba$7[ebp], 3
	jge	SHORT $LN20@conv_filte

; 48   : 			{
; 49   : 				*(imgDst +wr_base+rgba) = (unsigned char)(fval[rgba]);

	mov	eax, DWORD PTR _imgDst$[ebp]
	add	eax, DWORD PTR _wr_base$17[ebp]
	mov	ecx, DWORD PTR _rgba$7[ebp]
	mov	edx, DWORD PTR _rgba$7[ebp]
	mov	dl, BYTE PTR _fval$14[ebp+edx*2]
	mov	BYTE PTR [eax+ecx], dl

; 50   : 			}

	jmp	SHORT $LN19@conv_filte
$LN20@conv_filte:

; 51   : 			wr_base = wr_base + 3;

	mov	eax, DWORD PTR _wr_base$17[ebp]
	add	eax, 3
	mov	DWORD PTR _wr_base$17[ebp], eax

; 52   : 			rd_base = rd_base + 3;

	mov	eax, DWORD PTR _rd_base$16[ebp]
	add	eax, 3
	mov	DWORD PTR _rd_base$16[ebp], eax

; 53   : 		}

	jmp	$LN4@conv_filte
$LN5@conv_filte:

; 54   : 		wr_base = wr_base + 4*3;

	mov	eax, DWORD PTR _wr_base$17[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _wr_base$17[ebp], eax

; 55   : 		rd_base = rd_base + 4*3;

	mov	eax, DWORD PTR _rd_base$16[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _rd_base$16[ebp], eax
	jmp	$LN2@conv_filte
$LN3@conv_filte:

; 18   : 	for (int row=0; row<imgHeight; row++)

	call	__vcomp_for_static_end
$LN27@conv_filte:

; 56   : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@conv_filte
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 416				; 000001a0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@conv_filte:
	DD	1
	DD	$LN4@conv_filte
$LN4@conv_filte:
	DD	-64					; ffffffc0H
	DD	6
	DD	$LN3@conv_filte
$LN3@conv_filte:
	DB	102					; 00000066H
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
?conv_filter$omp$1@@YAXHHHPAFPAE1@Z ENDP		; conv_filter$omp$1
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\vs_projects\hetero_hw_1\_src\conv_filter.cpp
;	COMDAT ?conv_filter@@YAXHHHPAFPAE1@Z
_TEXT	SEGMENT
_imgHeight$ = 8						; size = 4
_imgWidth$ = 12						; size = 4
_imgWidthF$ = 16					; size = 4
_filter$ = 20						; size = 4
_imgSrcExt$ = 24					; size = 4
_imgDst$ = 28						; size = 4
?conv_filter@@YAXHHHPAFPAE1@Z PROC			; conv_filter, COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 13   : 
; 14   : #if USE_OMP==1
; 15   : 	#pragma omp parallel for

	mov	eax, DWORD PTR _imgDst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _imgSrcExt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _filter$[ebp]
	push	edx
	mov	eax, DWORD PTR _imgWidthF$[ebp]
	push	eax
	mov	ecx, DWORD PTR _imgWidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _imgHeight$[ebp]
	push	edx
	push	OFFSET ?conv_filter$omp$1@@YAXHHHPAFPAE1@Z ; conv_filter$omp$1
	push	6
	push	1
	call	__vcomp_fork
	add	esp, 36					; 00000024H

; 16   : #else
; 17   : #endif
; 18   : 	for (int row=0; row<imgHeight; row++)
; 19   : 	{
; 20   : 		int wr_base = row*imgWidth*3;
; 21   : 		int rd_base = row*imgWidthF*3;
; 22   : 		for (int col=0; col<imgWidth; col++)
; 23   : 		{
; 24   : 			short fval[3] = {0,0,0};
; 25   : 			int rd_offset = 0;
; 26   : 			for (int fy=0; fy<FILTER_H; fy++)
; 27   : 			{
; 28   : 				for (int fx=0; fx<FILTER_W; fx++)
; 29   : 				{
; 30   : 					for (int rgba=0; rgba<3; rgba++)
; 31   : 					{
; 32   : 						int pixel_src = rd_base + rd_offset;
; 33   : 						fval[rgba] = fval[rgba] + *(filter+fy*FILTER_W+fx) * (short)(*(imgSrcExt + pixel_src + rgba));
; 34   : 					}
; 35   : 					rd_offset = rd_offset + 3;
; 36   : 				}
; 37   : 				rd_offset = rd_offset - 5*3 + imgWidthF*3;
; 38   : 				
; 39   : 			}
; 40   : 
; 41   : 			for (int rgba=0; rgba<3; rgba++)
; 42   : 			{
; 43   : 				if (fval[rgba]>255) fval[rgba]=255;
; 44   : 				if (fval[rgba]<0)   fval[rgba]=0;
; 45   : 			}
; 46   : 
; 47   : 			for (int rgba=0; rgba<3; rgba++)
; 48   : 			{
; 49   : 				*(imgDst +wr_base+rgba) = (unsigned char)(fval[rgba]);
; 50   : 			}
; 51   : 			wr_base = wr_base + 3;
; 52   : 			rd_base = rd_base + 3;
; 53   : 		}
; 54   : 		wr_base = wr_base + 4*3;
; 55   : 		rd_base = rd_base + 4*3;
; 56   : 	}
; 57   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN30@conv_filte
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@conv_filte:
	DD	1
	DD	$LN29@conv_filte
$LN29@conv_filte:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN28@conv_filte
$LN28@conv_filte:
	DB	95					; 0000005fH
	DB	36					; 00000024H
	DB	65					; 00000041H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	0
?conv_filter@@YAXHHHPAFPAE1@Z ENDP			; conv_filter
_TEXT	ENDS
END
