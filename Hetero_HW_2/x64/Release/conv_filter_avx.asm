; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?conv_filter_avx@@YAXHHHPEAFPEAE1@Z		; conv_filter_avx
;	COMDAT pdata
pdata	SEGMENT
$pdata$?conv_filter_avx@@YAXHHHPEAFPEAE1@Z DD imagerel $LN6
	DD	imagerel $LN6+212
	DD	imagerel $unwind$?conv_filter_avx@@YAXHHHPEAFPEAE1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?conv_filter_avx$omp$1@@YAXHHHPEAFPEAE1@Z DD imagerel ?conv_filter_avx$omp$1@@YAXHHHPEAFPEAE1@Z
	DD	imagerel ?conv_filter_avx$omp$1@@YAXHHHPEAFPEAE1@Z+530
	DD	imagerel $unwind$?conv_filter_avx$omp$1@@YAXHHHPEAFPEAE1@Z
;	COMDAT xdata
xdata	SEGMENT
$unwind$?conv_filter_avx$omp$1@@YAXHHHPEAFPEAE1@Z DD 0154001H
	DD	099837H
	DD	0a8832H
	DD	0b782dH
	DD	0c6828H
	DD	0237423H
	DD	0226423H
	DD	0213423H
	DD	01a0123H
	DD	0e01af01cH
	DD	0c016d018H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?conv_filter_avx@@YAXHHHPEAFPEAE1@Z DD 032f19H
	DD	0740115H
	DD	0500eH
	DD	imagerel __GSHandlerCheck
	DD	0324H
	DD	070H
	DD	020H
; Function compile flags: /Ogtpy
; File d:\bme\education\ujrakonfig_2018\gyak\gyak1_mo\_src\conv_filter_avx.cpp
;	COMDAT ?conv_filter_avx$omp$1@@YAXHHHPEAFPEAE1@Z
_TEXT	SEGMENT
$T1 = 0
tv997 = 4
$T2 = 4
fval$3 = 32
filter_laplace$ = 256
imgHeight$ = 264
imgWidth$ = 272
imgWidthF$ = 280
imgSrcExt$ = 288
imgDst$ = 296
?conv_filter_avx$omp$1@@YAXHHHPEAFPEAE1@Z PROC		; conv_filter_avx$omp$1, COMDAT
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	mov	QWORD PTR [rax+8], rcx
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 208				; 000000d0H
	vmovaps	XMMWORD PTR [rax-56], xmm6
	vmovaps	XMMWORD PTR [rax-72], xmm7
	vmovaps	XMMWORD PTR [rax-88], xmm8
	vmovaps	XMMWORD PTR [rax-104], xmm9
	lea	rbp, QWORD PTR [rsp+80]
	and	rbp, -32				; ffffffffffffffe0H

; 27   : 	for (int row=0; row<imgHeight; row++)

	mov	edx, DWORD PTR [rdx]
	mov	rbx, r9
	mov	rdi, r8
	test	edx, edx
	jle	$LN1@conv_filte
	lea	rax, QWORD PTR $T2[rbp]
	mov	r9d, 1
	mov	QWORD PTR [rsp+40], rax
	dec	edx
	lea	rax, QWORD PTR $T1[rbp]
	xor	ecx, ecx
	mov	r8d, r9d
	mov	QWORD PTR [rsp+32], rax
	call	_vcomp_for_static_simple_init
	mov	esi, DWORD PTR $T1[rbp]
	mov	r12d, DWORD PTR $T2[rbp]
	cmp	esi, r12d
	jg	$LN6@conv_filte

; 28   : 	{
; 29   : 		int wr_base = row*imgWidth*3;

	mov	ecx, DWORD PTR [rdi]

; 30   : 		int rd_base = row*imgWidthF*3;

	mov	r15d, DWORD PTR [rbx]
	mov	r14, QWORD PTR imgSrcExt$[rsp]
	mov	DWORD PTR tv997[rbp], ecx
	lea	r13d, DWORD PTR [rcx+rcx*2]
	npad	8
$LL2@conv_filte:
	mov	eax, r15d
	imul	eax, esi
	lea	r9d, DWORD PTR [rax+rax*2]

; 31   : 		// step through all components in a line
; 32   : 		for (int col=0; col<(imgWidth*3); col=col+16)

	test	r13d, r13d
	jle	$LN5@conv_filte

; 28   : 	{
; 29   : 		int wr_base = row*imgWidth*3;

	mov	rdi, QWORD PTR filter_laplace$[rsp]
	lea	r11d, DWORD PTR [r13-1]
	vmovdqu	ymm9, YMMWORD PTR __ymm@00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff
	mov	eax, ecx
	shr	r11d, 4
	imul	eax, esi
	lea	ebx, DWORD PTR [r15+r15*2]
	vpxor	xmm8, xmm8, xmm8
	lea	eax, DWORD PTR [rax+rax*2]
	movsxd	rdx, eax
	add	rdx, QWORD PTR imgDst$[rsp]
	inc	r11d
	npad	6
$LL9@conv_filte:

; 33   : 		{
; 34   : 			__m256i fval;
; 35   : 			fval = _mm256_set1_epi16(0);

	vmovdqu	ymm3, ymm8
	mov	r8d, r9d
	lea	rcx, QWORD PTR [rdi+96]
	mov	r10d, 5
$LL12@conv_filte:

; 36   : 
; 37   : 			int rd_offset = 0;
; 38   : 			for (int fy=0; fy<FILTER_H; fy++)
; 39   : 			{
; 40   : #if LOOP_UNROLL==0
; 41   : 				for (int fx=0; fx<FILTER_W; fx++)
; 42   : #endif
; 43   : 				{
; 44   : 					int pixel_src = rd_base + rd_offset;
; 45   : 					__m128i load_data;
; 46   : 					__m256i conv_res, mul_res;
; 47   : 
; 48   : #if LOOP_UNROLL==0
; 49   : 					load_data = _mm_lddqu_si128((__m128i *)(imgSrcExt + pixel_src));
; 50   : 					conv_res = _mm256_cvtepu8_epi16(load_data);
; 51   : 					mul_res = _mm256_mullo_epi16(conv_res, filter_laplace[fy * 5 + fx]);
; 52   : 					fval = _mm256_add_epi16(fval, mul_res);
; 53   : 					rd_offset = rd_offset + 3;
; 54   : #else
; 55   : 					load_data = _mm_lddqu_si128((__m128i *)(imgSrcExt + pixel_src + 0));

	movsxd	rax, r8d
	lea	rcx, QWORD PTR [rcx+160]

; 56   : 					conv_res = _mm256_cvtepu8_epi16(load_data);
; 57   : 					mul_res = _mm256_mullo_epi16(conv_res, filter_laplace[fy * 5 + 0]);
; 58   : 					fval = _mm256_add_epi16(fval, mul_res);
; 59   : 
; 60   : 					load_data = _mm_lddqu_si128((__m128i *)(imgSrcExt + pixel_src + 3));
; 61   : 					conv_res = _mm256_cvtepu8_epi16(load_data);
; 62   : 					mul_res = _mm256_mullo_epi16(conv_res, filter_laplace[fy * 5 + 1]);
; 63   : 					fval = _mm256_add_epi16(fval, mul_res);
; 64   : 
; 65   : 					load_data = _mm_lddqu_si128((__m128i *)(imgSrcExt + pixel_src + 6));
; 66   : 					conv_res = _mm256_cvtepu8_epi16(load_data);
; 67   : 					mul_res = _mm256_mullo_epi16(conv_res, filter_laplace[fy * 5 + 2]);
; 68   : 					fval = _mm256_add_epi16(fval, mul_res);
; 69   : 
; 70   : 					load_data = _mm_lddqu_si128((__m128i *)(imgSrcExt + pixel_src + 9));
; 71   : 					conv_res = _mm256_cvtepu8_epi16(load_data);
; 72   : 					mul_res = _mm256_mullo_epi16(conv_res, filter_laplace[fy * 5 + 3]);
; 73   : 					fval = _mm256_add_epi16(fval, mul_res);
; 74   : 
; 75   : 					load_data = _mm_lddqu_si128((__m128i *)(imgSrcExt + pixel_src + 12));
; 76   : 					conv_res = _mm256_cvtepu8_epi16(load_data);
; 77   : 					mul_res = _mm256_mullo_epi16(conv_res, filter_laplace[fy * 5 + 4]);
; 78   : 					fval = _mm256_add_epi16(fval, mul_res);
; 79   : #endif
; 80   : 				}
; 81   : #if LOOP_UNROLL==0
; 82   : 				rd_offset = rd_offset - 5*3 + imgWidthF*3;
; 83   : #else
; 84   : 				rd_offset = rd_offset + imgWidthF * 3;

	add	r8d, ebx
	vlddqu	xmm0, XMMWORD PTR [rax+r14+12]
	vpmovzxbw ymm1, xmm0
	vpmullw	ymm7, ymm1, YMMWORD PTR [rcx-128]
	vlddqu	xmm0, XMMWORD PTR [rax+r14+9]
	vpmovzxbw ymm1, xmm0
	vpmullw	ymm6, ymm1, YMMWORD PTR [rcx-160]
	vlddqu	xmm0, XMMWORD PTR [rax+r14+6]
	vpmovzxbw ymm1, xmm0
	vpmullw	ymm5, ymm1, YMMWORD PTR [rcx-192]
	vlddqu	xmm0, XMMWORD PTR [rax+r14+3]
	vpmovzxbw ymm1, xmm0
	vpmullw	ymm4, ymm1, YMMWORD PTR [rcx-224]
	vlddqu	xmm0, XMMWORD PTR [rax+r14]
	vpmovzxbw ymm1, xmm0
	vpmullw	ymm2, ymm1, YMMWORD PTR [rcx-256]
	vpaddw	ymm3, ymm2, ymm3
	vpaddw	ymm0, ymm3, ymm4
	vpaddw	ymm1, ymm0, ymm5
	vpaddw	ymm2, ymm1, ymm6
	vpaddw	ymm3, ymm2, ymm7
	sub	r10, 1
	jne	$LL12@conv_filte

; 85   : #endif
; 86   : 			}
; 87   : 
; 88   : 			__m256i sat_val;
; 89   : 			sat_val = _mm256_set1_epi16(255);
; 90   : 			fval = _mm256_min_epi16(fval, sat_val);

	vpminsw	ymm0, ymm9, ymm3

; 91   : 			sat_val = _mm256_set1_epi16(0);
; 92   : 			fval = _mm256_max_epi16(fval, sat_val);

	vpmaxsw	ymm1, ymm0, ymm8
	vmovdqu	YMMWORD PTR fval$3[rbp], ymm1

; 93   : 
; 94   : 			__m256i *res_vec_ptr;
; 95   : 			res_vec_ptr = &fval;
; 96   : 			short *res_short_ptr;
; 97   : 			res_short_ptr = (short*)(res_vec_ptr);
; 98   : 
; 99   : 			for (int i = 0; i < 16; i++)

	xor	eax, eax
	npad	3
$LL15@conv_filte:

; 100  : 			{
; 101  : 				*(imgDst + wr_base + i) = *(res_short_ptr + i);

	movzx	ecx, BYTE PTR fval$3[rbp+rax*2]
	mov	BYTE PTR [rdx+rax], cl
	inc	rax
	cmp	rax, 16
	jl	SHORT $LL15@conv_filte

; 102  : 			}
; 103  : 
; 104  : 			wr_base = wr_base + 16;

	add	rdx, 16

; 105  : 			rd_base = rd_base + 16;

	add	r9d, 16
	sub	r11, 1
	jne	$LL9@conv_filte
	mov	ecx, DWORD PTR tv997[rbp]
$LN5@conv_filte:

; 27   : 	for (int row=0; row<imgHeight; row++)

	inc	esi
	cmp	esi, r12d
	jle	$LL2@conv_filte
$LN6@conv_filte:
	vzeroupper
	call	_vcomp_for_static_end
$LN1@conv_filte:

; 106  : 		}
; 107  : 	}

	lea	r11, QWORD PTR [rsp+208]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	vmovaps	xmm6, XMMWORD PTR [r11-16]
	vmovaps	xmm7, XMMWORD PTR [r11-32]
	vmovaps	xmm8, XMMWORD PTR [r11-48]
	vmovaps	xmm9, XMMWORD PTR [r11-64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
?conv_filter_avx$omp$1@@YAXHHHPEAFPEAE1@Z ENDP		; conv_filter_avx$omp$1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\bme\education\ujrakonfig_2018\gyak\gyak1_mo\_src\conv_filter_avx.cpp
;	COMDAT ?conv_filter_avx@@YAXHHHPEAFPEAE1@Z
_TEXT	SEGMENT
filter_laplace$ = 0
__$ArrayPad$ = 800
imgHeight$ = 944
imgWidth$ = 952
imgWidthF$ = 960
filter$ = 968
imgSrcExt$ = 976
imgDst$ = 984
?conv_filter_avx@@YAXHHHPEAFPEAE1@Z PROC		; conv_filter_avx, COMDAT

; 14   : {

$LN6:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 928				; 000003a0H
	lea	rbp, QWORD PTR [rsp+112]
	and	rbp, -32				; ffffffffffffffe0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp], rax

; 15   : 	// Generate the vector-coefficients
; 16   : 	__m256i filter_laplace[25];
; 17   : 	for (int i = 0; i < 25; i++)

	xor	eax, eax
	lea	rdx, QWORD PTR filter_laplace$[rbp]
	npad	11
$LL4@conv_filte:

; 18   : 	{
; 19   : 		filter_laplace[i] = _mm256_set1_epi16(filter[i]);

	movsx	ecx, WORD PTR [r9+rax*2]
	lea	rdx, QWORD PTR [rdx+32]
	vmovd	xmm0, ecx
	vpbroadcastw ymm0, xmm0
	inc	rax
	vmovdqu	YMMWORD PTR [rdx-32], ymm0
	cmp	rax, 25
	jl	SHORT $LL4@conv_filte

; 20   : 	}
; 21   : 
; 22   : 
; 23   : #if USE_OMP==1
; 24   : 	#pragma omp parallel for

	mov	rax, QWORD PTR imgDst$[rsp]
	lea	r9, QWORD PTR filter_laplace$[rbp]
	mov	QWORD PTR [rsp+64], rax
	lea	r8, OFFSET FLAT:?conv_filter_avx$omp$1@@YAXHHHPEAFPEAE1@Z ; conv_filter_avx$omp$1
	mov	rax, QWORD PTR imgSrcExt$[rsp]
	mov	edx, 6
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR imgWidthF$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR imgWidth$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR imgHeight$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	ecx, QWORD PTR [rdx-5]
	vzeroupper
	call	_vcomp_fork

; 25   : #else
; 26   : #endif
; 27   : 	for (int row=0; row<imgHeight; row++)
; 28   : 	{
; 29   : 		int wr_base = row*imgWidth*3;
; 30   : 		int rd_base = row*imgWidthF*3;
; 31   : 		// step through all components in a line
; 32   : 		for (int col=0; col<(imgWidth*3); col=col+16)
; 33   : 		{
; 34   : 			__m256i fval;
; 35   : 			fval = _mm256_set1_epi16(0);
; 36   : 
; 37   : 			int rd_offset = 0;
; 38   : 			for (int fy=0; fy<FILTER_H; fy++)
; 39   : 			{
; 40   : #if LOOP_UNROLL==0
; 41   : 				for (int fx=0; fx<FILTER_W; fx++)
; 42   : #endif
; 43   : 				{
; 44   : 					int pixel_src = rd_base + rd_offset;
; 45   : 					__m128i load_data;
; 46   : 					__m256i conv_res, mul_res;
; 47   : 
; 48   : #if LOOP_UNROLL==0
; 49   : 					load_data = _mm_lddqu_si128((__m128i *)(imgSrcExt + pixel_src));
; 50   : 					conv_res = _mm256_cvtepu8_epi16(load_data);
; 51   : 					mul_res = _mm256_mullo_epi16(conv_res, filter_laplace[fy * 5 + fx]);
; 52   : 					fval = _mm256_add_epi16(fval, mul_res);
; 53   : 					rd_offset = rd_offset + 3;
; 54   : #else
; 55   : 					load_data = _mm_lddqu_si128((__m128i *)(imgSrcExt + pixel_src + 0));
; 56   : 					conv_res = _mm256_cvtepu8_epi16(load_data);
; 57   : 					mul_res = _mm256_mullo_epi16(conv_res, filter_laplace[fy * 5 + 0]);
; 58   : 					fval = _mm256_add_epi16(fval, mul_res);
; 59   : 
; 60   : 					load_data = _mm_lddqu_si128((__m128i *)(imgSrcExt + pixel_src + 3));
; 61   : 					conv_res = _mm256_cvtepu8_epi16(load_data);
; 62   : 					mul_res = _mm256_mullo_epi16(conv_res, filter_laplace[fy * 5 + 1]);
; 63   : 					fval = _mm256_add_epi16(fval, mul_res);
; 64   : 
; 65   : 					load_data = _mm_lddqu_si128((__m128i *)(imgSrcExt + pixel_src + 6));
; 66   : 					conv_res = _mm256_cvtepu8_epi16(load_data);
; 67   : 					mul_res = _mm256_mullo_epi16(conv_res, filter_laplace[fy * 5 + 2]);
; 68   : 					fval = _mm256_add_epi16(fval, mul_res);
; 69   : 
; 70   : 					load_data = _mm_lddqu_si128((__m128i *)(imgSrcExt + pixel_src + 9));
; 71   : 					conv_res = _mm256_cvtepu8_epi16(load_data);
; 72   : 					mul_res = _mm256_mullo_epi16(conv_res, filter_laplace[fy * 5 + 3]);
; 73   : 					fval = _mm256_add_epi16(fval, mul_res);
; 74   : 
; 75   : 					load_data = _mm_lddqu_si128((__m128i *)(imgSrcExt + pixel_src + 12));
; 76   : 					conv_res = _mm256_cvtepu8_epi16(load_data);
; 77   : 					mul_res = _mm256_mullo_epi16(conv_res, filter_laplace[fy * 5 + 4]);
; 78   : 					fval = _mm256_add_epi16(fval, mul_res);
; 79   : #endif
; 80   : 				}
; 81   : #if LOOP_UNROLL==0
; 82   : 				rd_offset = rd_offset - 5*3 + imgWidthF*3;
; 83   : #else
; 84   : 				rd_offset = rd_offset + imgWidthF * 3;
; 85   : #endif
; 86   : 			}
; 87   : 
; 88   : 			__m256i sat_val;
; 89   : 			sat_val = _mm256_set1_epi16(255);
; 90   : 			fval = _mm256_min_epi16(fval, sat_val);
; 91   : 			sat_val = _mm256_set1_epi16(0);
; 92   : 			fval = _mm256_max_epi16(fval, sat_val);
; 93   : 
; 94   : 			__m256i *res_vec_ptr;
; 95   : 			res_vec_ptr = &fval;
; 96   : 			short *res_short_ptr;
; 97   : 			res_short_ptr = (short*)(res_vec_ptr);
; 98   : 
; 99   : 			for (int i = 0; i < 16; i++)
; 100  : 			{
; 101  : 				*(imgDst + wr_base + i) = *(res_short_ptr + i);
; 102  : 			}
; 103  : 
; 104  : 			wr_base = wr_base + 16;
; 105  : 			rd_base = rd_base + 16;
; 106  : 		}
; 107  : 	}
; 108  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 928				; 000003a0H
	pop	rbp
	ret	0
?conv_filter_avx@@YAXHHHPEAFPEAE1@Z ENDP		; conv_filter_avx
_TEXT	ENDS
END
