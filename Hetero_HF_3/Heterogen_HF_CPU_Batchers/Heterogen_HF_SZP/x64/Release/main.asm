; Listing generated by Microsoft (R) Optimizing Compiler Version 19.14.26430.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_09HDLCNAPM@input?4jpg?$AA@		; `string'
PUBLIC	??_C@_0BL@EIJCCJGD@Input?5resolution?3?5?$CF4dx?$CF4d?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@NGKMKCMP@C?5CPU?5TIME?3?5?$CF4?44f?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@CKJPLJHO@C?5Mpixel?1s?3?5?$CF4?44f?6?$AA@ ; `string'
PUBLIC	??_C@_0L@DMOPMCBB@output?4jpg?$AA@		; `string'
EXTRN	__imp_ilGenImages:PROC
EXTRN	__imp_ilGetInteger:PROC
EXTRN	__imp_ilGetData:PROC
EXTRN	__imp_ilBindImage:PROC
EXTRN	__imp_ilInit:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	__imp_iluInit:PROC
EXTRN	_aligned_malloc:PROC
EXTRN	__imp_ilDeleteImages:PROC
EXTRN	__imp_ilLoadImage:PROC
EXTRN	__acrt_iob_func:PROC
EXTRN	__imp_ilSetData:PROC
EXTRN	__imp_ilEnable:PROC
EXTRN	__imp_ilSaveImage:PROC
EXTRN	clock:PROC
EXTRN	_aligned_free:PROC
;	COMDAT ??_C@_0L@DMOPMCBB@output?4jpg?$AA@
CONST	SEGMENT
??_C@_0L@DMOPMCBB@output?4jpg?$AA@ DB 'output.jpg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CKJPLJHO@C?5Mpixel?1s?3?5?$CF4?44f?6?$AA@
CONST	SEGMENT
??_C@_0BD@CKJPLJHO@C?5Mpixel?1s?3?5?$CF4?44f?6?$AA@ DB 'C Mpixel/s: %4.4f'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NGKMKCMP@C?5CPU?5TIME?3?5?$CF4?44f?6?$AA@
CONST	SEGMENT
??_C@_0BD@NGKMKCMP@C?5CPU?5TIME?3?5?$CF4?44f?6?$AA@ DB 'C CPU TIME: %4.4f'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EIJCCJGD@Input?5resolution?3?5?$CF4dx?$CF4d?6?$AA@
CONST	SEGMENT
??_C@_0BL@EIJCCJGD@Input?5resolution?3?5?$CF4dx?$CF4d?6?$AA@ DB 'Input re'
	DB	'solution: %4dx%4d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HDLCNAPM@input?4jpg?$AA@
CONST	SEGMENT
??_C@_09HDLCNAPM@input?4jpg?$AA@ DB 'input.jpg', 00H	; `string'
CONST	ENDS
PUBLIC	main
PUBLIC	printf
PUBLIC	_vfprintf_l
PUBLIC	__local_stdio_printf_options
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN102
	DD	imagerel $LN102+37
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$main DD imagerel $LN102+37
	DD	imagerel $LN102+303
	DD	imagerel $chain$0$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$main DD imagerel $LN102+303
	DD	imagerel $LN102+1543
	DD	imagerel $chain$2$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$main DD imagerel $LN102+1543
	DD	imagerel $LN102+2249
	DD	imagerel $chain$3$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN6
	DD	imagerel $LN6+83
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 041b01H
	DD	07017521bH
	DD	030156016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$main DD 040021H
	DD	02ff400H
	DD	02ee400H
	DD	imagerel $LN102
	DD	imagerel $LN102+37
	DD	imagerel $unwind$main
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$main DD 041021H
	DD	02ff410H
	DD	02ee408H
	DD	imagerel $LN102+37
	DD	imagerel $LN102+303
	DD	imagerel $chain$0$main
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$main DD 020921H
	DD	0136809H
	DD	imagerel $LN102
	DD	imagerel $LN102+37
	DD	imagerel $unwind$main
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	092519H
	DD	0303413H
	DD	0280113H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0120H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$dead$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, rdx
	mov	rsi, rcx

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rbx
	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 640  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Format$ = 80
printf	PROC						; COMDAT

; 950  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	__acrt_iob_func
	mov	rbx, rax

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 955  :     __crt_va_end(_ArgList);
; 956  :     return _Result;
; 957  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\d_strabi\d dokumentumai\bme\heterogén számítási rendszerek\hf\private_dev\dev\heterogen_hf_cpu_batchers\heterogen_hf_szp\_src\main.cpp
; File d:\d_strabi\d dokumentumai\bme\heterogén számítási rendszerek\hf\private_dev\dev\heterogen_hf_cpu_batchers\heterogen_hf_szp\_src\conv_filter.cpp
; File d:\d_strabi\d dokumentumai\bme\heterogén számítási rendszerek\hf\private_dev\dev\heterogen_hf_cpu_batchers\heterogen_hf_szp\_src\main.cpp
;	COMDAT main
_TEXT	SEGMENT
imgWidth$1$ = 32
tv13623 = 36
tv13562 = 36
imgHeight$1$ = 40
imgFloatRes$1$ = 48
tv13622 = 48
ilImg$ = 56
s0$1$ = 64
tv13550 = 64
imgWidthF$1$ = 64
imgData$1$ = 72
imgFloat$1$ = 80
tv13618 = 88
tv13549 = 88
tv13617 = 96
tv13556 = 96
tv13642 = 104
tv13572 = 104
tv13640 = 112
tv13592 = 112
tv13594 = 120
tv13574 = 120
tv13645 = 128
tv13527 = 128
tv13602 = 136
tv13600 = 144
tv13596 = 152
tv13559 = 160
tv13561 = 168
fval$1 = 176
__$ArrayPad$ = 288
main	PROC						; COMDAT

; 230  : {

$LN102:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	sub	rsp, 320				; 00000140H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	vmovaps	XMMWORD PTR [rsp+304], xmm6

; 231  : 	ilInit(); iluInit();

	call	QWORD PTR __imp_ilInit
	call	QWORD PTR __imp_iluInit

; 232  : 	ILboolean ret;
; 233  : 	ILuint ilImg=0;

	xor	r13d, r13d

; 234  : 	ilGenImages(1, &ilImg);

	lea	rdx, QWORD PTR ilImg$[rsp]
	mov	DWORD PTR ilImg$[rsp], r13d
	lea	ecx, QWORD PTR [r13+1]
	call	QWORD PTR __imp_ilGenImages

; 235  : 	ilBindImage(ilImg);

	mov	ecx, DWORD PTR ilImg$[rsp]
	call	QWORD PTR __imp_ilBindImage

; 236  :     ret = ilLoadImage((const char*)("input.jpg"));

	lea	rcx, OFFSET FLAT:??_C@_09HDLCNAPM@input?4jpg?$AA@
	call	QWORD PTR __imp_ilLoadImage

; 237  : 	ILubyte* imgData = ilGetData(); 

	call	QWORD PTR __imp_ilGetData

; 238  : 
; 239  : 	int imgWidth = ilGetInteger(IL_IMAGE_WIDTH);

	mov	ecx, 3556				; 00000de4H
	mov	QWORD PTR imgData$1$[rsp], rax
	mov	rsi, rax
	call	QWORD PTR __imp_ilGetInteger

; 240  : 	int imgHeight = ilGetInteger(IL_IMAGE_HEIGHT);

	mov	ecx, 3557				; 00000de5H
	mov	DWORD PTR imgWidth$1$[rsp], eax
	mov	r12d, eax
	call	QWORD PTR __imp_ilGetInteger
	mov	ebp, eax

; 241  : 	ILint imgOrigin = ilGetInteger(IL_ORIGIN_MODE);

	mov	ecx, 1539				; 00000603H
	mov	DWORD PTR imgHeight$1$[rsp], ebp
	call	QWORD PTR __imp_ilGetInteger

; 242  : 
; 243  : 	printf("Input resolution: %4dx%4d\n", imgWidth, imgHeight);

	mov	r8d, ebp
	lea	rcx, OFFSET FLAT:??_C@_0BL@EIJCCJGD@Input?5resolution?3?5?$CF4dx?$CF4d?6?$AA@
	mov	edx, r12d
	call	printf

; 244  : 
; 245  : 	float *imgFloat;
; 246  : 	int imgWidthF = imgWidth+FILTER_W-1;

	lea	ebx, DWORD PTR [r12+4]

; 247  : 	int imgHeightF = imgHeight+FILTER_H-1;

	lea	edi, DWORD PTR [rbp+4]
	mov	DWORD PTR imgWidthF$1$[rsp], ebx

; 248  : 	int imgFOffsetW = (FILTER_W-1)/2;
; 249  : 	int imgFOffsetH = (FILTER_H-1)/2;
; 250  : 	imgFloat   = (float *)(_aligned_malloc(4*imgWidthF*imgHeightF*sizeof(float), 32));

	mov	eax, edi
	lea	edx, QWORD PTR [r13+32]
	imul	eax, ebx
	shl	eax, 2
	cdqe
	shl	rax, 2
	mov	rcx, rax
	mov	QWORD PTR tv13645[rsp], rax
	call	_aligned_malloc
	mov	QWORD PTR imgFloat$1$[rsp], rax
	mov	r8, rax

; 251  :     int row, col;
; 252  : 
; 253  : 	for (row=0; row<imgHeightF; row++)

	test	edi, edi
	jle	SHORT $LN3@main

; 231  : 	ilInit(); iluInit();

	lea	ecx, DWORD PTR [rbx*4]
	mov	r8d, edi
	movsxd	r9, ecx
	lea	rdx, QWORD PTR [rax+8]
	shl	r9, 2
$LL4@main:

; 254  : 	{
; 255  : 		for (col=0; col<imgWidthF;col++)

	test	ebx, ebx
	jle	SHORT $LN2@main
	mov	rax, rdx
	mov	ecx, ebx
	npad	2
$LL7@main:

; 256  : 		{
; 257  : 			int pixel = (row*imgWidthF + col)*4;
; 258  : 			*(imgFloat+pixel+0) = 0.0f;

	mov	QWORD PTR [rax-8], r13

; 259  : 			*(imgFloat + pixel + 1) = 0.0f;
; 260  : 			*(imgFloat + pixel + 2) = 0.0f;

	mov	QWORD PTR [rax], r13
	lea	rax, QWORD PTR [rax+16]
	sub	rcx, 1
	jne	SHORT $LL7@main
$LN2@main:

; 251  :     int row, col;
; 252  : 
; 253  : 	for (row=0; row<imgHeightF; row++)

	add	rdx, r9
	sub	r8, 1
	jne	SHORT $LL4@main
	mov	r8, QWORD PTR imgFloat$1$[rsp]
$LN3@main:
	mov	QWORD PTR [rsp+368], r14
	mov	QWORD PTR [rsp+376], r15

; 261  : 			*(imgFloat + pixel + 3) = 0.0f;
; 262  : 		}
; 263  : 	}
; 264  : 
; 265  : 	for (row=0; row<imgHeight; row++)

	test	ebp, ebp
	jle	$LN9@main
	lea	eax, DWORD PTR [r12+r12*2]
	mov	r14d, r13d
	cdqe
	lea	ecx, DWORD PTR [rbx*8]
	mov	QWORD PTR tv13594[rsp], rax
	lea	r15d, DWORD PTR [rbx+rbx]
	movsxd	rsi, ecx
	lea	eax, DWORD PTR [rbx*4]
	cdqe
	add	rsi, 8
	mov	QWORD PTR tv13642[rsp], rax
	mov	rdi, r13
	movsxd	rbp, ecx
	mov	ecx, DWORD PTR imgHeight$1$[rsp]
	lea	rax, QWORD PTR [rax*4]
	mov	DWORD PTR tv13623[rsp], r15d
	mov	QWORD PTR tv13640[rsp], rax
	lea	r12, QWORD PTR [rsi+6]
	lea	eax, DWORD PTR [rbx*8+16]
	mov	QWORD PTR tv13618[rsp], rsi
	movsxd	r13, eax
	lea	r12, QWORD PTR [r8+r12*4]
	mov	eax, DWORD PTR imgWidth$1$[rsp]
	sub	r13, rsi
	sub	rbp, rsi
	mov	QWORD PTR tv13617[rsp], r12
	mov	QWORD PTR tv13622[rsp], rcx
	npad	4
$LL10@main:

; 266  : 	{
; 267  : 		for (col=0; col<imgWidth;col++)

	xor	r11d, r11d
	cmp	eax, 4
	jl	$LC82@main
	mov	rbx, QWORD PTR imgData$1$[rsp]
	lea	rcx, QWORD PTR [rdi+9]
	mov	rax, rcx
	mov	r10, rbx
	sub	rax, rdi
	mov	r8, r12
	add	rax, -3
	mov	QWORD PTR tv13602[rsp], rax
	lea	rdx, QWORD PTR [rbx+1]
	sub	rax, rdx
	lea	r11, QWORD PTR [rbx-3]
	add	r11, rax
	lea	r9, QWORD PTR [rdx+3]
	dec	rax
	mov	QWORD PTR tv13600[rsp], r11
	add	rax, rbx
	sub	rcx, rdx
	mov	QWORD PTR tv13596[rsp], rax
	sub	rcx, rdi
	mov	rsi, QWORD PTR tv13596[rsp]
	sub	r10, rdx
	mov	rdx, QWORD PTR tv13602[rsp]
	add	r9, rdi
	lea	rax, QWORD PTR [rcx+rbx]
	mov	QWORD PTR tv13559[rsp], rax
	lea	rax, QWORD PTR [rbx+2]
	mov	rbx, QWORD PTR tv13600[rsp]
	add	rax, rcx
	mov	r15, QWORD PTR tv13559[rsp]
	mov	QWORD PTR tv13561[rsp], rax
	mov	eax, DWORD PTR imgWidth$1$[rsp]
	mov	r12, QWORD PTR tv13561[rsp]
	add	eax, -4					; fffffffcH
	shr	eax, 2
	inc	eax
	mov	ecx, eax
	lea	r11d, DWORD PTR [rax*4]
	npad	6
$LL83@main:

; 268  : 		{
; 269  : 			int pixel_dst = ((row+imgFOffsetH)*imgWidthF + (col+imgFOffsetW))*4;
; 270  : 			int pixel_src = (row*imgWidth + col)*3;
; 271  : 			*(imgFloat+pixel_dst+0) = (float)(*(imgData+pixel_src+0));

	movzx	eax, BYTE PTR [r10+r9-3]

; 274  : 			*(imgFloat+pixel_dst+3) = 0.0;

	lea	r8, QWORD PTR [r8+64]
	lea	r9, QWORD PTR [r9+12]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vmovss	DWORD PTR [r8-88], xmm0
	movzx	eax, BYTE PTR [r9-15]
	vxorps	xmm0, xmm0, xmm0
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, eax
	vmovss	DWORD PTR [r8-84], xmm1
	movzx	eax, BYTE PTR [r9-14]
	vcvtsi2ss xmm0, xmm0, eax
	vmovss	DWORD PTR [r8-80], xmm0
	mov	DWORD PTR [r8-76], 0
	movzx	eax, BYTE PTR [r10+r9-12]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vmovss	DWORD PTR [r8-72], xmm0
	movzx	eax, BYTE PTR [r9-12]
	vxorps	xmm0, xmm0, xmm0
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, eax
	vmovss	DWORD PTR [r8-68], xmm1
	movzx	eax, BYTE PTR [r9-11]
	vcvtsi2ss xmm0, xmm0, eax
	vmovss	DWORD PTR [r8-64], xmm0
	mov	DWORD PTR [r8-60], 0
	movzx	eax, BYTE PTR [rbx+r9-12]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vmovss	DWORD PTR [r8+r13*4-88], xmm0
	movzx	eax, BYTE PTR [rdx+r9-15]
	vxorps	xmm0, xmm0, xmm0
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, eax
	vmovss	DWORD PTR [r8+r13*4-84], xmm1
	movzx	eax, BYTE PTR [rsi+r9-12]
	vcvtsi2ss xmm0, xmm0, eax
	vmovss	DWORD PTR [r8+r13*4-80], xmm0
	mov	DWORD PTR [r8+r13*4-76], 0
	movzx	eax, BYTE PTR [r9+r15-15]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vmovss	DWORD PTR [r8+rbp*4-8], xmm0
	movzx	eax, BYTE PTR [r9-6]
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, eax
	vmovss	DWORD PTR [r8+rbp*4-4], xmm1
	movzx	eax, BYTE PTR [r9+r12-15]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vmovss	DWORD PTR [r8+rbp*4], xmm0
	mov	DWORD PTR [r8+rbp*4+4], 0
	sub	rcx, 1
	jne	$LL83@main
	mov	ebx, DWORD PTR imgWidthF$1$[rsp]
	mov	rsi, QWORD PTR tv13618[rsp]
	mov	r15d, DWORD PTR tv13623[rsp]
	mov	r12, QWORD PTR tv13617[rsp]
	mov	eax, DWORD PTR imgWidth$1$[rsp]
	mov	rcx, QWORD PTR tv13622[rsp]
	mov	r8, QWORD PTR imgFloat$1$[rsp]
$LC82@main:

; 266  : 	{
; 267  : 		for (col=0; col<imgWidth;col++)

	cmp	r11d, eax
	jge	$LN8@main
	mov	r10, QWORD PTR imgData$1$[rsp]
	lea	eax, DWORD PTR [r14+r11]
	lea	ecx, DWORD PTR [rax+rax*2]
	movsxd	r9, ecx
	lea	eax, DWORD PTR [r15+r11]
	lea	eax, DWORD PTR [rax*4+8]
	movsxd	rcx, eax
	lea	rdx, QWORD PTR [r10+1]
	add	r9, rdx
	sub	r10, rdx
	lea	r8, QWORD PTR [r8+rcx*4]
	mov	ecx, DWORD PTR imgWidth$1$[rsp]
	add	r8, 8
	sub	ecx, r11d
$LC13@main:

; 268  : 		{
; 269  : 			int pixel_dst = ((row+imgFOffsetH)*imgWidthF + (col+imgFOffsetW))*4;
; 270  : 			int pixel_src = (row*imgWidth + col)*3;
; 271  : 			*(imgFloat+pixel_dst+0) = (float)(*(imgData+pixel_src+0));

	movzx	eax, BYTE PTR [r9+r10]
	lea	r8, QWORD PTR [r8+16]
	lea	r9, QWORD PTR [r9+3]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vmovss	DWORD PTR [r8-24], xmm0

; 272  : 			*(imgFloat+pixel_dst+1) = (float)(*(imgData+pixel_src+1));

	movzx	eax, BYTE PTR [r9-3]
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, eax
	vmovss	DWORD PTR [r8-20], xmm1

; 273  : 			*(imgFloat+pixel_dst+2) = (float)(*(imgData+pixel_src+2));

	movzx	eax, BYTE PTR [r9-2]

; 274  : 			*(imgFloat+pixel_dst+3) = 0.0;

	mov	DWORD PTR [r8-12], 0
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vmovss	DWORD PTR [r8-16], xmm0
	sub	rcx, 1
	jne	SHORT $LC13@main
	mov	eax, DWORD PTR imgWidth$1$[rsp]
	mov	rcx, QWORD PTR tv13622[rsp]
$LN8@main:

; 261  : 			*(imgFloat + pixel + 3) = 0.0f;
; 262  : 		}
; 263  : 	}
; 264  : 
; 265  : 	for (row=0; row<imgHeight; row++)

	add	rsi, QWORD PTR tv13642[rsp]
	add	r15d, ebx
	add	r12, QWORD PTR tv13640[rsp]
	add	r14d, eax
	add	rdi, QWORD PTR tv13594[rsp]
	mov	r8, QWORD PTR imgFloat$1$[rsp]
	sub	rcx, 1
	mov	QWORD PTR tv13622[rsp], rcx
	mov	QWORD PTR tv13618[rsp], rsi
	mov	QWORD PTR tv13617[rsp], r12
	mov	DWORD PTR tv13623[rsp], r15d
	jne	$LL10@main
	mov	r12d, DWORD PTR imgWidth$1$[rsp]
	mov	rsi, QWORD PTR imgData$1$[rsp]
	mov	ebp, DWORD PTR imgHeight$1$[rsp]
$LN9@main:

; 275  : 		}
; 276  : 	}
; 277  : 
; 278  : 
; 279  : // IMAGE PROCESSING
; 280  : //---------------------------------------------------------------------------------------
; 281  : 	clock_t s0, e0;
; 282  :     double d0;
; 283  : 
; 284  : 	float *imgFloatRes;
; 285  :     imgFloatRes = (float *)(_aligned_malloc(4*imgWidthF*imgHeightF*sizeof(float), 32));

	mov	rcx, QWORD PTR tv13645[rsp]
	mov	edx, 32					; 00000020H
	call	_aligned_malloc
	mov	rdi, rax
	mov	QWORD PTR imgFloatRes$1$[rsp], rax

; 286  : 
; 287  : 	float filter_laplace[] = {-1.0, -1.0, -1.0, -1.0, -1.0,
; 288  : 		                      -1.0, -1.0, -1.0, -1.0, -1.0,
; 289  : 		                      -1.0, -1.0, 24.0, -1.0, -1.0,
; 290  : 		                      -1.0, -1.0, -1.0, -1.0, -1.0,
; 291  : 		                      -1.0, -1.0, -1.0, -1.0, -1.0};
; 292  : 	double mpixel;
; 293  : 
; 294  : 
; 295  : 	s0 = clock();

	call	clock
	mov	DWORD PTR s0$1$[rsp], eax
; File d:\d_strabi\d dokumentumai\bme\heterogén számítási rendszerek\hf\private_dev\dev\heterogen_hf_cpu_batchers\heterogen_hf_szp\_src\conv_filter.cpp

; 397  : 	for (int y=0; y<imgHeight; y++)

	test	ebp, ebp
	jle	$LN14@main
	mov	r14, QWORD PTR imgFloat$1$[rsp]
	lea	ecx, DWORD PTR [r12*4]
	mov	r15d, DWORD PTR imgHeight$1$[rsp]
	mov	rbp, rdi
	movsxd	r13, ecx
	movsxd	r9, ebx
	shl	r13, 2
	shl	r9, 4
	add	r14, 32					; 00000020H
$LL27@main:

; 398  : 	{
; 399  : 		// A sorokon belül végiglépkedünk egy sor pixelein
; 400  : 		for (int x=0; x<imgWidth; x++)

	test	r12d, r12d
	jle	$LN25@main

; 409  : 					for (int dx = 0; dx < 5; dx++) {
; 410  : 						fval[dy * 5 + dx] = imgFloatSrc[(y*imgWidthF + x + dy*imgWidthF + dx) * 4 + rgb];

	mov	r10, r14
	mov	edi, r12d
	mov	r11, rbp
	npad	10
$LL30@main:

; 401  : 		{
; 402  : 			for (int rgb = 0; rgb < 4; rgb++) {

	mov	ebx, 4
$LL33@main:

; 403  : 
; 404  : 			
; 405  : 			// RGBA komponensek akkumulátora
; 406  : 				float fval[25];
; 407  : 
; 408  : 				for (int dy = 0; dy < 5; dy++) {

	lea	rcx, QWORD PTR fval$1[rsp+4]
	mov	rdx, r10
	mov	r8d, 5
	npad	10
$LL36@main:

; 409  : 					for (int dx = 0; dx < 5; dx++) {
; 410  : 						fval[dy * 5 + dx] = imgFloatSrc[(y*imgWidthF + x + dy*imgWidthF + dx) * 4 + rgb];

	mov	eax, DWORD PTR [rdx-32]
	mov	DWORD PTR [rcx-4], eax
	lea	rcx, QWORD PTR [rcx+20]
	mov	eax, DWORD PTR [rdx-16]
	mov	DWORD PTR [rcx-20], eax
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx-16], eax
	mov	eax, DWORD PTR [rdx+16]
	mov	DWORD PTR [rcx-12], eax
	mov	eax, DWORD PTR [rdx+32]
	add	rdx, r9
	mov	DWORD PTR [rcx-8], eax
	sub	r8, 1
	jne	SHORT $LL36@main

; 411  : 					}
; 412  : 				}
; 413  : 
; 414  : 				oddeven(fval);

	lea	rcx, QWORD PTR fval$1[rsp]
	call	?oddeven@@YAXPEAM@Z			; oddeven

; 415  : 
; 416  : 				imgFloatDst[(y*imgWidth + x) * 4 + rgb] = fval[12];

	vmovss	xmm0, DWORD PTR fval$1[rsp+48]
	vmovss	DWORD PTR [r11], xmm0
	add	r11, 4
	add	r10, 4
	sub	rbx, 1
	jne	SHORT $LL33@main

; 398  : 	{
; 399  : 		// A sorokon belül végiglépkedünk egy sor pixelein
; 400  : 		for (int x=0; x<imgWidth; x++)

	sub	rdi, 1
	jne	SHORT $LL30@main
$LN25@main:

; 397  : 	for (int y=0; y<imgHeight; y++)

	add	r14, r9
	add	rbp, r13
	sub	r15, 1
	jne	$LL27@main
	mov	ebp, DWORD PTR imgHeight$1$[rsp]
$LN14@main:
; File d:\d_strabi\d dokumentumai\bme\heterogén számítási rendszerek\hf\private_dev\dev\heterogen_hf_cpu_batchers\heterogen_hf_szp\_src\main.cpp

; 303  :     e0 = clock();

	call	clock

; 304  :     d0 = (double)(e0-s0)/(RUNS*CLOCKS_PER_SEC);

	sub	eax, DWORD PTR s0$1$[rsp]

; 305  : 	mpixel = (imgWidth*imgHeight/d0)/1000000;
; 306  :     printf("C CPU TIME: %4.4f\n", d0);

	lea	rcx, OFFSET FLAT:??_C@_0BD@NGKMKCMP@C?5CPU?5TIME?3?5?$CF4?44f?6?$AA@
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2sd xmm0, xmm0, eax
	vdivsd	xmm6, xmm0, QWORD PTR __real@408f400000000000
	vmovaps	xmm1, xmm6
	vmovq	rdx, xmm1
	call	printf
	mov	eax, ebp

; 307  : 	printf("C Mpixel/s: %4.4f\n", mpixel);

	lea	rcx, OFFSET FLAT:??_C@_0BD@CKJPLJHO@C?5Mpixel?1s?3?5?$CF4?44f?6?$AA@
	imul	eax, r12d
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2sd xmm0, xmm0, eax
	vdivsd	xmm1, xmm0, xmm6
	vdivsd	xmm1, xmm1, QWORD PTR __real@412e848000000000
	vmovq	rdx, xmm1
	call	printf
	vmovaps	xmm6, XMMWORD PTR [rsp+304]

; 308  : 
; 309  : 
; 310  : 
; 311  : 	float *imgFloatWrite;
; 312  : 	imgFloatWrite = imgFloatRes;
; 313  : 
; 314  : //---------------------------------------------------------------------------------------
; 315  : // IMAGE PROCESSING END
; 316  : 
; 317  : 
; 318  : 	for (row=0; row<imgHeight; row++)

	test	ebp, ebp
	jle	$LN18@main

; 304  :     d0 = (double)(e0-s0)/(RUNS*CLOCKS_PER_SEC);

	mov	r9, QWORD PTR imgFloatRes$1$[rsp]
	lea	eax, DWORD PTR [r12+r12*2]
	movsxd	r13, eax
	xor	r11d, r11d
	lea	eax, DWORD PTR [r12*4]
	mov	DWORD PTR tv13562[rsp], r11d
	movsxd	r15, eax
	xor	esi, esi
	xor	r14d, r14d
	mov	QWORD PTR tv13592[rsp], r13
	lea	rdi, QWORD PTR [r9+24]
	mov	QWORD PTR tv13556[rsp], r14
	mov	QWORD PTR tv13574[rsp], r15
	lea	rax, QWORD PTR [r15*4]
	mov	QWORD PTR tv13549[rsp], rdi
	mov	QWORD PTR tv13572[rsp], rax
	mov	QWORD PTR tv13550[rsp], rbp
	npad	11
$LL19@main:

; 319  : 	{
; 320  : 		for (col=0; col<imgWidth;col++)

	xor	ebx, ebx
	cmp	r12d, 4
	jl	$LC85@main
	mov	rbx, QWORD PTR imgData$1$[rsp]
	lea	r9, QWORD PTR [r14+12]
	mov	r8, rdi
	mov	r10, r9
	lea	rdi, QWORD PTR [rsi+9]
	mov	r11, rbx
	mov	rbp, rdi
	sub	r10, r14
	lea	rcx, QWORD PTR [rbx+1]
	sub	rbp, rsi
	sub	rdi, rsi
	lea	rdx, QWORD PTR [rcx+3]
	sub	r9, r14
	sub	r11, rcx
	add	rdx, rsi
	lea	rax, QWORD PTR [rbp-3]
	sub	rax, rcx
	lea	r15, QWORD PTR [rax+rbx]
	lea	r12, QWORD PTR [rbx+rax]
	mov	rax, rdi
	sub	rax, rcx
	lea	r13, QWORD PTR [rax+rbx]
	dec	rax
	add	rax, rbx
	mov	QWORD PTR tv13527[rsp], rax
	mov	eax, DWORD PTR imgWidth$1$[rsp]
	mov	r14, QWORD PTR tv13527[rsp]
	add	eax, -4					; fffffffcH
	shr	eax, 2
	inc	eax
	mov	ecx, eax
	lea	ebx, DWORD PTR [rax*4]
	npad	13
$LL86@main:

; 326  : 			*(imgData+pixel_dst+2) = (ILubyte)(*(imgFloatWrite+pixel_src+2));

	lea	rdx, QWORD PTR [rdx+12]
	vcvttss2si eax, DWORD PTR [r8-24]
	mov	BYTE PTR [r11+rdx-15], al
	vcvttss2si eax, DWORD PTR [r8-20]
	mov	BYTE PTR [rdx-15], al
	vcvttss2si eax, DWORD PTR [r8-16]
	mov	BYTE PTR [rdx-14], al
	vcvttss2si eax, DWORD PTR [r8-8]
	mov	BYTE PTR [rdx+r11-12], al
	vcvttss2si eax, DWORD PTR [r8-4]
	mov	BYTE PTR [rdx-12], al
	vcvttss2si eax, DWORD PTR [r8]
	mov	BYTE PTR [rdx-11], al
	vcvttss2si eax, DWORD PTR [r8+r10*4-40]
	mov	BYTE PTR [rdx+r15-15], al
	vcvttss2si eax, DWORD PTR [r8+r10*4-36]
	mov	BYTE PTR [rdx+rbp-18], al
	vcvttss2si eax, DWORD PTR [r8+r10*4-32]
	mov	BYTE PTR [rdx+r12-13], al
	vcvttss2si eax, DWORD PTR [r8+r9*4-24]
	mov	BYTE PTR [rdx+r13-15], al
	vcvttss2si eax, DWORD PTR [r8+r9*4-20]
	mov	BYTE PTR [rdx+rdi-15], al
	vcvttss2si eax, DWORD PTR [r8+r9*4-16]
	mov	BYTE PTR [rdx+r14-12], al
	lea	r8, QWORD PTR [r8+64]
	sub	rcx, 1
	jne	$LL86@main
	mov	r14, QWORD PTR tv13556[rsp]
	mov	r11d, DWORD PTR tv13562[rsp]
	mov	rdi, QWORD PTR tv13549[rsp]
	mov	rbp, QWORD PTR tv13550[rsp]
	mov	r12d, DWORD PTR imgWidth$1$[rsp]
	mov	r15, QWORD PTR tv13574[rsp]
	mov	r13, QWORD PTR tv13592[rsp]
	mov	rax, QWORD PTR tv13572[rsp]
	mov	r9, QWORD PTR imgFloatRes$1$[rsp]
$LC85@main:

; 319  : 	{
; 320  : 		for (col=0; col<imgWidth;col++)

	cmp	ebx, r12d
	jge	SHORT $LN17@main
	mov	r10, QWORD PTR imgData$1$[rsp]
	lea	ecx, DWORD PTR [r11+rbx]
	lea	eax, DWORD PTR [rcx+rcx*2]
	movsxd	r8, eax
	lea	eax, DWORD PTR [rcx*4]
	movsxd	rcx, eax
	lea	rdx, QWORD PTR [r10+1]
	add	r8, rdx
	sub	r10, rdx
	lea	r9, QWORD PTR [r9+rcx*4]
	mov	ecx, r12d
	add	r9, 8
	sub	ecx, ebx
$LC22@main:
	lea	r8, QWORD PTR [r8+3]

; 321  : 		{
; 322  : 			int pixel_src = (row*imgWidth + col)*4;
; 323  : 			int pixel_dst = (row*imgWidth + col)*3;
; 324  : 			*(imgData+pixel_dst+0) = (ILubyte)(*(imgFloatWrite+pixel_src+0));

	vcvttss2si eax, DWORD PTR [r9-8]
	mov	BYTE PTR [r8+r10-3], al

; 325  : 			*(imgData+pixel_dst+1) = (ILubyte)(*(imgFloatWrite+pixel_src+1));

	vcvttss2si eax, DWORD PTR [r9-4]
	mov	BYTE PTR [r8-3], al

; 326  : 			*(imgData+pixel_dst+2) = (ILubyte)(*(imgFloatWrite+pixel_src+2));

	vcvttss2si eax, DWORD PTR [r9]
	mov	BYTE PTR [r8-2], al
	lea	r9, QWORD PTR [r9+16]
	sub	rcx, 1
	jne	SHORT $LC22@main
	lea	rax, QWORD PTR [r15*4]
$LN17@main:

; 308  : 
; 309  : 
; 310  : 
; 311  : 	float *imgFloatWrite;
; 312  : 	imgFloatWrite = imgFloatRes;
; 313  : 
; 314  : //---------------------------------------------------------------------------------------
; 315  : // IMAGE PROCESSING END
; 316  : 
; 317  : 
; 318  : 	for (row=0; row<imgHeight; row++)

	mov	r9, QWORD PTR imgFloatRes$1$[rsp]
	add	r11d, r12d
	add	r14, r15
	mov	DWORD PTR tv13562[rsp], r11d
	add	rdi, rax
	mov	QWORD PTR tv13556[rsp], r14
	add	rsi, r13
	mov	QWORD PTR tv13549[rsp], rdi
	sub	rbp, 1
	mov	QWORD PTR tv13550[rsp], rbp
	jne	$LL19@main
	mov	rsi, QWORD PTR imgData$1$[rsp]
$LN18@main:

; 327  : 		}
; 328  : 	}
; 329  : 
; 330  : 
; 331  : 	_aligned_free(imgFloat);

	mov	rcx, QWORD PTR imgFloat$1$[rsp]
	call	_aligned_free

; 332  :     _aligned_free(imgFloatRes);

	mov	rcx, QWORD PTR imgFloatRes$1$[rsp]
	call	_aligned_free

; 333  : 
; 334  : 	ret = ilSetData(imgData);

	mov	rcx, rsi
	call	QWORD PTR __imp_ilSetData

; 335  : 	ilEnable(IL_FILE_OVERWRITE);

	mov	ecx, 1568				; 00000620H
	call	QWORD PTR __imp_ilEnable

; 336  :     ilSaveImage((const char*)("output.jpg"));

	lea	rcx, OFFSET FLAT:??_C@_0L@DMOPMCBB@output?4jpg?$AA@
	call	QWORD PTR __imp_ilSaveImage

; 337  : 	ilDeleteImages(1, &ilImg);

	lea	rdx, QWORD PTR ilImg$[rsp]
	mov	ecx, 1
	call	QWORD PTR __imp_ilDeleteImages

; 338  : }

	mov	r15, QWORD PTR [rsp+376]
	xor	eax, eax
	mov	r14, QWORD PTR [rsp+368]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+384]
	add	rsp, 320				; 00000140H
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
main	ENDP
_TEXT	ENDS
END
